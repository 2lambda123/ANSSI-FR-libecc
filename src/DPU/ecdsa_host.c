#include <assert.h>
#include <stdio.h>

#include <dpu.h>
#include <dpu_log.h>

#ifndef DPU_BINARY
#define DPU_BINARY "./ecdsa_dpu"
#endif

const uint8_t public_key[] = {
    0xd8, 0x14, 0x7d, 0x49, 0xe0, 0x7c, 0x32, 0x66,
	0x59, 0x8b, 0x85, 0xd6, 0x61, 0x50, 0xda, 0xc3,
	0x0d, 0x7b, 0x38, 0xe4, 0x3c, 0xc9, 0x40, 0x58,
	0x23, 0x50, 0x1c, 0x70, 0x91, 0xdb, 0x86, 0x1c,
	0x0e, 0x98, 0x17, 0xdf, 0x71, 0x76, 0x91, 0xed,
	0x83, 0x3d, 0xe6, 0x1b, 0x7b, 0x64, 0xc9, 0x77,
	0xb8, 0xf8, 0x37, 0xc2, 0xc1, 0x0a, 0xdf, 0xd9,
	0xf3, 0x83, 0xce, 0x78, 0xc7, 0xf7, 0x89, 0x78
};


/* SHA-256 of "abc" msg */
const uint8_t calculated_hash[] = {
    0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,
    0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,
    0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c,
    0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad
};

#ifndef SIG_KO
static const uint8_t signature_ok[] =
{
    0x9b, 0x19, 0xcf, 0x16, 0xee, 0xa0, 0x0f, 0x03,  0xde, 0x7b, 0x59, 0x14, 0xa4, 0x4c, 0x9f, 0xad,
    0xe7, 0x7e, 0xf9, 0x9d, 0x2e, 0x78, 0x23, 0xf5,  0x63, 0xda, 0x75, 0xac, 0x1b, 0x15, 0x50, 0x28,
    0x00, 0xb8, 0x78, 0x72, 0x28, 0x22, 0xdd, 0x56,  0xd2, 0x14, 0xe9, 0x36, 0x92, 0xca, 0x58, 0x71,
    0x73, 0xe8, 0xaa, 0x2d, 0x8d, 0x6c, 0xfe, 0x9c,  0x1d, 0x91, 0xa3, 0xb5, 0x4b, 0x6f, 0xf4, 0x83
};
#else
/* last byte modified */
static const uint8_t signature_ko[] =
{
    0x9b, 0x19, 0xcf, 0x16, 0xee, 0xa0, 0x0f, 0x03,  0xde, 0x7b, 0x59, 0x14, 0xa4, 0x4c, 0x9f, 0xad,
    0xe7, 0x7e, 0xf9, 0x9d, 0x2e, 0x78, 0x23, 0xf5,  0x63, 0xda, 0x75, 0xac, 0x1b, 0x15, 0x50, 0x28,
    0x00, 0xb8, 0x78, 0x72, 0x28, 0x22, 0xdd, 0x56,  0xd2, 0x14, 0xe9, 0x36, 0x92, 0xca, 0x58, 0x71,
    0x73, 0xe8, 0xaa, 0x2d, 0x8d, 0x6c, 0xfe, 0x9c,  0x1d, 0x91, 0xa3, 0xb5, 0x4b, 0x6f, 0xf4, 0x81
};
#endif
int main(void)
{
    struct dpu_set_t set, dpu;
    int dpu_ret = 0xff;
#ifndef GEN_BY_SW
    uint32_t dpu_cycles = 0xAA;
    uint32_t clock_per_sec = 0xAA;
#endif

    DPU_ASSERT(dpu_alloc(1, NULL, &set));
    DPU_ASSERT(dpu_load(set, DPU_BINARY, NULL));
    DPU_ASSERT(dpu_broadcast_to(set, "mram_public_key", 0, public_key, sizeof(public_key), DPU_XFER_DEFAULT));
    DPU_ASSERT(dpu_broadcast_to(set, "mram_hash", 0, calculated_hash, sizeof(calculated_hash), DPU_XFER_DEFAULT));
#ifndef SIG_KO
    DPU_ASSERT(dpu_broadcast_to(set, "mram_signature", 0, signature_ok, sizeof(signature_ok), DPU_XFER_DEFAULT));
#else
    DPU_ASSERT(dpu_broadcast_to(set, "mram_signature", 0, signature_ko, sizeof(signature_ko), DPU_XFER_DEFAULT));
#endif
    DPU_ASSERT(dpu_launch(set, DPU_SYNCHRONOUS));

    DPU_FOREACH (set, dpu) {
#ifdef GEN_BY_SW
        DPU_ASSERT(dpu_log_read(dpu, stdout));
#endif
        DPU_ASSERT(dpu_copy_from(dpu, "ret", 0, (uint8_t *)&dpu_ret, sizeof(dpu_ret)));
        printf("ret value %d\n", dpu_ret);
#ifndef GEN_BY_SW
        DPU_ASSERT(dpu_copy_from(dpu, "cycles", 0, (uint8_t *)&dpu_cycles, sizeof(dpu_cycles)));
        DPU_ASSERT(dpu_copy_from(dpu, "clock_per_sec", 0, (uint8_t *)&clock_per_sec, sizeof(clock_per_sec)));
        printf("dpu_cycles %u\n", dpu_cycles);
        printf("clock_per_sec %u\n", clock_per_sec);
        printf("dpu_msec %u\n", dpu_cycles/(clock_per_sec/1000));
#endif
    }

    DPU_ASSERT(dpu_free(set));

    return 0;
}